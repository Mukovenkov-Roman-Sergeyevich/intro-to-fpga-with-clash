= 5. Шины и тестирование последовательностной логики

Дана задача:

[quote]
____
Пусть есть точки на отрезке.
Каждая точка характеризуется двумя параметрами: 8 бит координат и 3 бита цвет.
В систему каждый из параметров поступает последовательно по каналу шириной 1 бит.

Модуль обработки обрабатывает 11 бит за раз.
Необходимо написать конвертер двух последовательных входов в один параллельный.
____

На примере данной задачи и рассмотрим темы данного занятия.

== Шины

Редкая программа состоит из одной функции.
Мы привыкли к тому, что программа состоит множества функций, где одна вызывает другую.
Так и хороший дизайн состоит из нескольких модулей.
Однако все модули существуют одновременно, поэтому появляется необходимость синхронизировать модули друг с другом.

Для решения данной проблемы используются шинные протоколы, которые достаточно хорошо стандартизованы.
Одни из наиболее известных протоколов: AMBA AXI{empty}footnote:[Менее формальное описание можно найти здесь: https://habr.com/ru/articles/572926.
Пример реализации можно найти, например, тут: https://github.com/alexforencich/verilog-axis], WishBone, Avalon Bus.
Протоколы часто рассчитаны на различные топологии подключения: master-slave, конвейер данных, общая шина и другие.

Мы будем рассматривать топологию конвейер данных.

image::bus.svg[]

Каждый модуль одновременно является и master (префикс `m_`), и slave (префикс `s_`).

Когда один модуль готов отправить данные он записывает данные в `m_data` и поднимает сигнал `m_valid`, а затем ждёт готовности следующего модуля в цепочке.
Как только поднимается сигнал `m_ready`, происходит обмен данными.
Важно, что `m_valid` не может зависеть от `m_ready`.

== Конвертер последовательного сигнала в параллельный

Самым простым решением нашей задачи является использования трех блоков: один будет выдавать 8-битный параллельный сигнал, второй 3-битный параллельный сигнал, а третий будет их объединять.

Начнём решать нашу задачу с создания конвертера последовательного сигнала в параллельный.

[,verilog]
.src/05-bus/serial_to_parallel/serial_to_parallel.sv
----
include::example$serial_to_parallel.sv[]
----
<1> Параметризуем наш модуль шириной последовательного порта.
<2> Здесь будет использовать асинхронный (префикс `a`) сигнал сброса с активным нижним уровнем (суффикс `n`).
Асинхронность означает, что мы обязаны реагировать на сигнал сброса в любое время, а не только по фронту `clk`.
Активный нижний уровень означает, что обычное значение сигнала -- 1, а для сброса его необходимо сделать 0.
<3> Используем встроенную функцию `$clog2`, которая вычисляет логарифм по основанию 2, а затем округляет число вверх, чтобы вычислить сколько бит необходимо для того, чтобы досчитать до числа `OUT_WIDTH`-1.
<4> Данный блок отвечает за сохранение валидных битов.
Здесь в списке чувствительности указываем не только `clk`, но и `aresetn`.
<5> Проверяем стоит ли нам забирать входные данные.
<6> Такая конструкция часто называется сдвиговый регистр.
<7> Данный блок отвечает за учёт сохраненных битов.
<8> Данный блок отвечает за вывод сигналов.
<9> Единственный случай, когда мы не готовы принимать данные -- мы сформировали вывод, а следующее устройство в цепочке не готово его принять.

== Тестирование кода

Теперь наконец поговорим о более сложных тестбенчах.
На самом деле SystemVerilog предоставляет богатые возможности по написанию тестбенчей.
Здесь показан наиболее простой код, демонстрирующий основные концепции.
Дальше данный код можно расширять используя функции, задачи (аналог процедур), а также классы{empty}footnote:[Подробнее о возможностях языка рассказано в курсе Школы синтеза цифровых схем в лекциях 9-15 по адресу https://www.youtube.com/playlist?list=PLi3mfxNhwAi-Jul8__xY9Nhig8DZNxJFZ].

[,verilog]
.src/05-bus/serial_to_parallel/serial_to_parallel_tb.sv
----
include::example$serial_to_parallel_tb.sv[]
----
<1> Укажем время и временную точность симуляции{empty}footnote:[https://www.chipverify.com/verilog/verilog-timescale].
<2> Конструкции выше уже должны быть знакомы с прошлой темы.
Этот блок отвечает за генерацию входных сигналов.
<3> Цикл, который повторится заданное количество раз.
<4> Генерируем случайный вход.
<5> Держим данные пока принимающее устройство не готово.
<6> "Облегчаем" процесс коммуникации.
На самом деле обнулять сигнал `s_valid` нет необходимости.
<7> Именно этот блок контролирует момент конца симуляции.
<8> В данном блоке симулируем следующее устройство в цепи.
<9> Реализуем функциональность нашего блока в тестах, чтобы проверить корректность.
<10> Блок, в котором происходит проверка корректности работы.
<11> Данный блок закомментирован, но может быть удобен для отладки.
Обратите внимание на непривычный способ форматирования строки.
<12> Данный блок закончит симуляцию по таймауту.
Может быть очень полезен, если ваша симуляция зависла.
<13> Выгружаем сигналы для GTKWave.
В данном случае при помощи препроцессора запускаем данное действие только при использовании Icarus Verilog.

Итого, для тестирования модуля стоит использовать более близкие к обычным языкам программирования возможности SystemVerilog, а так же для рандомизированного тестирования стоит иметь модель модуля для сравнения результатов.
Однако создание модели на SystemVerilog бывает крайне неудобно, об альтернативных способах тестирования мы расскажем в следующих блоках.

== Объединение двух параллельных сигналов

Теперь нам нужно объединить два параллельных сигнала в один.
Посмотрим на код модуля, который реализует данное действие.

[#merge_parallel,verilog]
.src/05-bus/merge_parallel/merge_parallel.sv
----
include::example$merge_parallel.sv[]
----
<1> Параметры тоже могут зависеть от параметров.
К сожалению у такого подхода есть один минус: этот параметр всё так же можно менять при инстанциации.
<2> Правило хорошего тона: разбиваем логику работы с данными и с управляющими сигналами на два `always_ff` блока с одинаковым списком чувствительности.
В этом блоке работает с данными.
<3> А в этом с управляющими сигналами.

Однако теперь мы видим проблему: как только мы преобразовали все три бита в одном конвертере, он будет простаивать и дожидаться когда отработает второй конвертер.
Обычно такая проблема как раз возникает при использовании внешней периферии и для того, чтобы её смягчить используют более быстрый или более медленный управляющий сигнал.
К сожалению, перемещение сигнала между различными управляющими сигналами -- непростая задача, которая не будет освещена в данном курсе{empty}footnote:[Почитать подробнее про способы перехода между управляющими сигналами можно, например, тут: https://zipcpu.com/blog/2017/10/20/cdc.html].

Итоговый модуль может выглядеть примерно так:

[,verilog]
.src/05-bus/merge_serial_to_parallel.sv
----
include::example$merge_serial_to_parallel.sv[]
----

IMPORTANT: Обязательно порешайте xref:exercises.adoc[упражнения].
